# Построение модели определения стоимости автомобиля

## Описание проекта

Сервис по продаже автомобилей с пробегом  разрабатывает приложение для привлечения новых клиентов. В нём можно быстро узнать рыночную стоимость своего автомобиля.
На основе исторические данные необходимо построить модель для определения стоимости автомобиля.

## Ключевые слова проекта

`градиентный бустинг` `регрессия` `подбор гиперпараметров` `выбор модели МО`

## Навыки и инструменты

`исследовательский анализ данных` `Python` `Pandas` `NumPy` `lightgbm` `Scikit-learn`

## Результаты исследования

**I. В результате подготовки данных установлено:**

1. В столбце VehicleType (тип автомобильного кузова) - 10.6 % пропусков. Тип данных - object.
2. В столбце Gearbox (тип коробки передач) - 5.6 % пропусков. Тип данных - object.
3. В столбце Model (модель автомобиля) - 5.6 % пропусков. Тип данных - object.
4. В столбце FuelType (тип топлива) - 9.3 % пропусков. Тип данных - object.
5. В столбце NotRepaired (была машина в ремонте или нет) - 20.1 % пропусков. Тип данных - object.
6. Среди первых пяти потенциальных неявных дубликатов в списке (df['DateCrawled'].value_counts(ascending=False)) - неявные дубликаты не обнаружены.
7. Тип данных либо 'int', либо 'object'.
8. Аномальных данных в столбце 'RegistrationYear' порядка 4 %.
9. Аномальных данных в столбце 'Power' порядка 14 %.
10. Также имеется не значительное количество аномальных данных в столбце 'Price'.

**II. Процент не корректных данных очень большой (аномалий и пропусков). В целом, данных достаточно много (354369) и основная задача создать модель, которая будет точно предсказывать стоимость (значение метрики RMSE должно быть меньше 2500). Обучающие данные должны быть максимально приближены к реальным, однако, при заполнении пропусков средними или медианными значениями это может привести к недостаточно точной работе модели, плюс наличие большого количества аномалий также пагубно скажется на качестве модели. Устранение пропусков и аномалий через удаление - это то, что не повлияет на истинность оставшихся значений по которым будет обучаться модель. Попробуем пойти именно по этому пути и, если удастся достичь значения метрики RMSE меньше 2500 - будем считать, что примененный способ борьбы с пропусками и аномалиями уместен.**

**III. В результате обучение моделейна на данных с прямым кодированием и порядковым соответственно, установлено:**

1. Модель: LinearRegression(). RMSE: 2566. CPU times: user около 7 s. Модель: LinearRegression(). RMSE: 2954. CPU times: user около 89 ms.
2. Лучшие параметры модели: RandomForestRegressor(max_depth=5, n_estimators=5, random_state=12345). RMSE: 2376. CPU times: user около 46 s. Лучшие параметры модели: RandomForestRegressor(max_depth=5, n_estimators=5, random_state=12345). RMSE: 2379. CPU times: user около 9 s.
3. Лучшие параметры модели: DecisionTreeRegressor(max_depth=5, random_state=12345). RMSE: 2412. CPU times: user около 24 s. Лучшие параметры модели: DecisionTreeRegressor(max_depth=5, random_state=12345). RMSE: 2416. CPU times: user около 5 s.
4. Модель: DummyRegressor() RMSE: 4762. CPU times: user около 16 ms. Модель: DummyRegressor() RMSE: RMSE: 4762. CPU times: user около 24 ms.
5. Лучшие параметры модели: LGBMRegressor(max_depth=5, n_estimators=5, random_state=12345). RMSE: 3399. CPU times: user около 41 s. Лучшие параметры модели: LGBMRegressor(max_depth=5, n_estimators=5, random_state=12345). RMSE: 3401. CPU times: user около 10 s.


**IV. В результате анализа моделей, установлено:**

1. Наилучшая модель на ТЕСТОВОЙ выборке: RandomForestRegressor(max_depth=5, n_estimators=5, random_state=12345).
2. RMSE наилучшей модели на данных с прямым кодированием = 2336.4.
3. RMSE наилучшей модели на данных с порядковым кодированием = 2340.1.
 
 ## Статус проекта
 `Завершен`
